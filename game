--licensing is on bootup or:
--Game-Engine Copyright 2014 Jackson McNeill. Distribute any version, but show & keep this license
--end of license
--[[
Devmode:
This will automatically enables noclip & trace, and disables printing to the console
(if you're a developer you should probably have the logs open in a log viewer)
Use this for easier developement. You can stop trace, noclip console prints with
game.toggleTrace() , game.toggleNoclip() & game.toggleConsolePrint() respectavely.
PLEASE DO NOT RELEASE MODIFIED VERSIONS OF GAME-ENGINE WITH THIS LEFT ON!!!
]]
local devmode=true



--[[DO NOT CHANGE THIS LINE]] --[[]] local functionWhitespace=""--[[]] local consoleNL = "\n" --[[]] local useTraceCurrently = devmode --[[]]local noclip = devmode --[[]]local drawConsole = not devmode --[[]] local console ={}
--[[SET gameModded TO TRUE IF CLIENT IS MODDED, AND CHANGE THE UPDATER]] gameModded = nil numCmptbltyBreak = 0.9 numNewFtres = 5
local strVer = tostring(numCmptbltyBreak).."."..tostring(numNewFtres) --assemble the string version out of the numbers
--[[
/////////////\\\\\\\\\\\\
/Table of contents:     \
/Console functions      \
/[]
/Boot functions         \
/[]
/Mapping system         \
/[]
/Object system          \
/[]
/Player system          \
/[]
/AI system              \
/[N/A]                  \
/GUI system             \
/[]
/Temporary Library      \
/[]
/Compiler               \
/[]
/Misc.                  \
/[]                      
/////////////\\\\\\\\\\\\
]]
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--
--~~~[{DAMN THIS COMMENT IS FANCY}]~~~--
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--
if not redirect then
	error"You must load redirect before loading Game!"
end




---------------------------------------------------
-------[[Garbage/likely to be removed soon]]-------
---------------------------------------------------

--[[code shamelessly ripped from Sapphari & then expanded upon.
function sRead(startx, starty, endx, history) 
	if not history then
		history = {}
	end
	if type(startx)=="number"and type(starty) =="number"and type(endx)=="number"and type(history)=="table"then else
		writeErrorToConsole("sRead - incorrect variable types, must be number number number nil or table, got "..type(startx)..", "..type(starty)..", "..type(endx)..", "..type(history).." or nil.")
		return false
	end
	endx=endx+1
	term.setCursorBlink(true)
	local textThing = ""
	local textThingPrint=""
	local currentSpot = #history+1
	os.queueEvent("key",14)
	while true do
		evt, text = os.pullEvent()
		if evt == "key" then
			if text==14 then
				textThingPrint=string.sub(textThingPrint,1,#textThingPrint-1)
				term.setCursorPos(7,7)
				textThing=string.sub(textThing,1,#textThing-1)
				local textThingAdd=string.sub(textThing,#textThing-#textThingPrint,#textThing-#textThingPrint)
				textThingPrint = textThingAdd..textThingPrint
			elseif text==28 then
				term.setCursorBlink(false)
				return textThing
			elseif text==200 then
				--they're loading from a previous one
				if currentSpot>1 then
					currentSpot=currentSpot-1
					textThing = history[currentSpot]
					textThingPrint = textThing
				end
			elseif text==208 then
				--they're loading from a previous one
				if currentSpot<#history then
					currentSpot=currentSpot+1
					textThing = history[currentSpot]
					textThingPrint = textThing
				end
			end
		elseif evt == "char" then
			textThing=textThing..text
			textThingPrint=textThingPrint..text
		end
		term.setCursorPos(startx,starty)
		--format the string to fit the box
		--patch for deleting under max text box
		--length:
		if #textThingPrint ==(endx-startx) then
			textThingPrint = string.sub(textThingPrint,2,#textThingPrint)
		end
		local whitespacez = ""
		for i=1,endx-startx do
			--change that string VV for cool custom stuffz. Only one character, though!
			whitespacez = whitespacez.." "
		end
		term.setCursorPos(startx,starty)
		term.write(whitespacez)
		--reset cursor
		term.setCursorPos(startx,starty)
		term.write(textThingPrint)
		term.setCursorBlink(true)
	end
end]]
--------------------------
----[[Console System]]----
--------------------------
local function flushConsoleUi()
	for i=1,12 do
		paintutils.drawLine(1,i,51,i,colors.white)
	end
end

local function consoleInput()
	local ignoreVars = coroutine.yield()
	if type(ignoreVars)=="table"then else
		writeToConsole"openConsole - ignore function table did not exist or was not a table, ignoring..."
		ignoreVars={}
	end
	for i=1,#ignoreVars do
		if ignoreVars[i]=="openConsole" then
			local dontNeed=true
		end
	end
	if not dontNeed then
		ignoreVars[#ignoreVars+1]="openConsole"
	end
	flushConsoleUi()
	-----------------
	--[[Variables]]--
	-----------------
	local busted
	local lastCommands={}
	--metatables
	local env = {}
	setmetatable(env, {__index=_G})
	env["print"]=writeToConsole
	env["write"]=writeToConsole
	env["term.write"]=writeToConsole
	env["printError"]=writeErrorToConsole
	env["textutils.slowPrint"]=writeToConsole
	while true do
		term.setCursorPos(1,13)
		--refresh the bar
		paintutils.drawLine(1,13,51,13,colors.white)
		term.setTextColor(colors.black)
		lastCommands[#lastCommands+1]=read(nil,lastCommands)
		--check if the command is illegal
		for i=1,#ignoreVars do
			if string.find(lastCommands[#lastCommands],ignoreVars[i]) then
				busted = 'game.writeToConsole"[Console-CMD] You are not allowed to run that command!"'
			end
		end
		--print out the cmd
		writeToConsole("[Console-CMD] INPUT--> "..lastCommands[#lastCommands])
		--do something very necessary
		if lastCommands[#lastCommands]=="" then
			writeToConsole"[Console-CMD] You think you're so cool sending blank commands. They don't do anything. Really. Waste of your time. Maybe your time is worthless, and that is why you choose to spend it this way... hmph."
		elseif lastCommands[#lastCommands]=="yolo" then
			writeToConsole"[Console-CMD] Isn't that, I don't know, COMMON KNOWLEDGE?"
		elseif lastCommands[#lastCommands]=="lol" or lastCommands[#lastCommands]=="rofl" then
			writeToConsole"[Console-CMD] thanks, I needed to know you laughed"
		elseif lastCommands[#lastCommands]=="Activate GLaDOS" then
			writeToConsole"[GLaDOS] Oh. It's you. It's been a looong time."
		elseif lastCommands[#lastCommands]=="help"then
			writeToConsole"[Console-CMD] If you're asking this, you probably didn't mean to get here. Type exit and press enter to get out."
		elseif lastCommands[#lastCommands]=="nil" then
			writeToConsole"[Console-CMD] You know that that doesn't actually pass nil right? It passed \"nil\". So don't think you'll break the console."
		elseif lastCommands[#lastCommands]=="code 12345678910"then
			writeToConsole"[Console-CMD] Congratulations! You've cracked the password. You win! Really. That's it. You're done. You win the game... Is that what you wanted me to say? Let me let you in on a little secret: THERE'S NO PASSWORD. Really. There's nothing you can't access with a little Lua trickery. Sure, game devs can block you from directly using a function, but there are many many ways arround it."
		elseif string.lower(lastCommands[#lastCommands])=="exit" then
			writeToConsole"[Console-CMD] Closing..."
			return
		end
		--run the command
		local runThis,syntxerr = loadstring(busted or lastCommands[#lastCommands])
		busted = false
		--[[function env._echo(a)
			return a
		end]]
		if runThis then
			setfenv(runThis,env)
			local okay,err=pcall(runThis)
			if not okay then
				writeToConsole("[Console-CMD][Error] "..err or "")
			end
		else
			writeToConsole("[Console-CMD][Error]"..(string.sub(syntxerr,28,#syntxerr) or " Syntax Error."))
		end
	end
end
local function printConsole()
	while true do
		if drawConsole then
			console=console or {}--I don't even know how this is possible, but it's given me issues
			flushConsoleUi()
			term.setCursorPos(1,1)
			for i=#console-10,#console do
				print(console[i] or "")
			end
		else
			flushConsoleUi()
			term.setCursorPos(1,1)
			print"game.toggleConsolePrint() to turn on console printing."
		end
		sleep(0.5)
	end
end
function openConsole(ingoreVars)
	traceEnter"openconsole"
	local input = coroutine.create(consoleInput)
	local output = coroutine.create(printConsole)
	coroutine.resume(input,ignoreVars) --it wants this variable
	coroutine.resume(output,"refresh") -- it needs to draw to the screen
	local x
	while coroutine.status(input)=="suspended" and coroutine.status(output)=="suspended" do --while they're alive
		events = {os.pullEvent()}

		term.setBackgroundColor(colors.white)
		term.setTextColor(colors.black)
		x=term.getCursorPos()
		coroutine.resume(output,unpack(events))
		term.setCursorPos(x,13)
		coroutine.resume(input,unpack(events))
	end
	traceExit"openconsole"
end

function toggleConsolePrint()
	drawConsole= not drawConsole
end
function writeToConsole(txt)
	--write to the console
	--ensure correct syntax
	txt = tostring(txt) or txt
	if not type(txt) =="string" then
		writeErrorToConsole("writeToConsole - Expected String; got "..type(txt))
		return false
	end
	if fs.getFreeSpace"/" < #txt+18 then
		return "not enough space"
	end
	--add the whitespace
	txt=functionWhitespace..txt
	--open up console directory
	--[[if fs.exists"console.log" then
		local f=fs.open("console.log","r")
		log=f.readAll()
		f.close()
	end]]
	--write it
	consoleNL = consoleNL.."\n"..txt
	for i=0,math.ceil(#txt/51)-1 do
		console[#console+1]=string.sub(txt,(51*i)+1,(i+1)*51)
	end
	--console[#console+1]=txt
	f=fs.open("console.log","w")
	f.write(consoleNL)
	f.close()
end
function writeErrorToConsole(txt)
	--write an error to console
	--temp:
	writeToConsole("[ERROR] "..txt)
end
function l(...)
	writeToConsole(...)
end 
function e(...)
	writeErrorToConsole(...)
end
function flushLogs()
	local f=fs.open("console.log","w")
	f.writeLine""
	f.close()
end
if not noConsoleClear then 
	flushLogs()
end
function fatalError(errormsg)
	if not type(errormsg)=='string' then
		errormsg = "None provided."
	end
	--do something to report the fatal error
	writeErrorToConsole("FATAL - "..errormsg..". Displaying error gui and quiting.")
	term.setBackgroundColor(colors.red)
	term.setTextColor(colors.white)
	clear()
	term.setBackgroundColor(colors.gray)
	term.setTextColor(colors.red)
	cPrint"FATAL ERROR"
	print()
	cPrint(errormsg)
	cPrint"Game Engine could not continue running."
	print()print()
	cPrint"Press any key to continue."
	coroutine.yield"key"
	term.setBackgroundColor(colors.black)
	clear()
	error("FATAL: "..errormsg)
end
function traceEnter(txt)
	if useTraceCurrently then
		if not type(txt) =="string" then
			writeErrorToConsole("traceEnter - Expected String; got "..type(txt))
			return false
		end
		writeToConsole("Entering "..txt)
		functionWhitespace=functionWhitespace.."  "
	end
end
function traceExit(txt)
	if useTraceCurrently then
		if not type(txt) =="string" then
			writeErrorToConsole("traceExit - Expected String; got "..type(txt))
			return false
		end
		functionWhitespace=string.sub(functionWhitespace,1,#functionWhitespace-2)
		writeToConsole("Leaving "..txt)

	end
end
function inputCheck(variables,types,whatFunction)
	traceEnter"inputCheck"
	--check if it's a table
	whatFunction = whatFunction or "InputCheck(user)"
	if type(variables)=="table" and type(types)=="table" and type(whatFunction) =="string" then else
		writeErrorToConsole("inputCheck(in-function) - If you can't even give inputCheck the right type of variable, you're going to have issues. Wanted table, table, string got "..type(variable)..", "..type(variables)..", "..type(whatFunction))
		traceExit"inputCheck"
		return false
	end
	local bad,good
	local actuallyReport = ""
	for i=1,#types do
		--writeToConsole("b "..types[i])------------------
		if type(types[i])=="string" then--working
			types[i]={types[i]}--"string" --> types[i][1] > "string"
			--writeToConsole("a "..types[i][1])-------------------------------------------------------
		end
		good =false
		for o=1,#types[i] do
			
			if types[i][o] == type(variables[i]) then
				--writeToConsole"good"------------------------------------------------------
				--writeToConsole("m: "..types[i][o].." w: "..type(variables[i]))------------
				good = true 
				break
			else
				good= good or false
				--writeToConsole"bad"---------------
			end 
			--writeToConsole("p "..tostring(bad))---------------
			--writeToConsole("f "..tostring(bad))---------------
		end
		actuallyReport = actuallyReport..type(variables[i])..", " --ex: "table, table, "
	end
	--fix this later, but for now:
	bad = not good
 -- writeToConsole(actuallyReport.."also "..tostring(bad)..tostring(good))-------------------------------------
	if bad then --this is just plain english with bad grammer :D
		actuallyReport=string.sub(actuallyReport,1,#actuallyReport-2)--following ex, "table, table"
		--get all of what it was sopposed to be in a report
		perfectReport = whatFunction.." - Expected "
		for i=1,#types do
			for o=1,#types[i] do
				--writeToConsole(types[i])-----------------------------------------------------
				perfectReport=perfectReport..types[i][o].." or "--ex "table or string or "
			end
			perfectReport=string.sub(perfectReport,1,#perfectReport-4)..", " --ex "table or string, "
		 -- perfectReport=perfectReport..types[i][1]..", "  --ex: "Table, Table, "
		end
		writeErrorToConsole(string.sub(perfectReport,1,#perfectReport-2).."; got "..actuallyReport)
		traceExit"inputCheck"
		return true
	end
	traceExit"inputCheck"
end
function toggleTrace()
	useTraceCurrently = not useTraceCurrently
end
function toggleNoclip()
	noclip= not noclip
end
----------------------------------
-----[[Print Functions/misc]]-----
----------------------------------
function rest()
	os.queueEvent"noTooLongWithoutYielding"
	os.pullEvent"noTooLongWithoutYielding"
end
function setX(x)
	traceEnter"setX"
	if inputCheck({x},{"number"}) then
		traceExit"setX"
		return false
	end
	local _,y=term.getCursorPos()
	term.setCursorPos(x,y)
	traceExit"setX"
end
function cWrite(txt)
	traceEnter"cWrite"
	if inputCheck({txt},{"string"},"cWrite") then
		traceExit"cWrite"
		return false
	end
	local _,y=term.getCursorPos()
	term.setCursorPos(math.floor((term.getSize()-#txt)/2),y)
	write(txt)
	traceExit"cWrite"
end
function cPrint(txt)
	traceEnter"cPrint"
	cWrite(txt)
	print()
	traceExit"cPrint"
end
function clear(x,y)
	traceEnter"clear"
	if x or y then
		if inputCheck({x,y},{"number","number"},"clear") then
			traceExit"clear"
			return false
		end
	else
		x=1
		y=1
	end
	term.clear()
	term.setCursorPos(x,y)
	traceExit"clear"
end
--------------------
-----[[Bootup]]-----
--------------------
--initialize function
function initialize(version,build,fActbuild)
	traceEnter"initialize"
	if inputCheck({version,build,fActbuild},{"number","number","number"},"initialize") then
		traceExit"initialize"
		return false 

	end
	version = version+(build/10)
	actbuild = fActbuild
	if math.floor(numCmptbltyBreak)~=version then 
		term.clear()
		term.setCursorPos(1,1)
		error("This game was designed for Game-Engine version "..tostring(version).."."..tostring(fActbuild)..", and will not run on version "..strVer..". Please downgrade Game-Engine to a compatible version.")
	end 
	--check for updates
	




	traceExit"initialize"
end
function quit()
	numCmptbltyBreak,devmode,strVer,numNewFtres,gameModded,consoleNL,useTraceCurrently,functionWhitespace,noclip,drawConsole,console = nil 
end
--display powered by Game
local function cantCallDis(showLegal)
	clear()
	cPrint"POWERED BY:"
	--put in the game-engine logo thingy
	local logo = {{0,0,512,512,512,512,512,512,512,512,512,512,512,512,512,512,512,},{0,512,512,512,512,2,2,2,2,2,2,2,2,2,512,512,512,512,},{512,512,512,512,512,2,512,512,512,512,512,512,512,512,512,512,512,512,512,},{512,512,512,512,512,2,512,512,512,512,512,512,512,512,512,512,512,512,512,},{512,512,512,512,512,2,512,512,512,512,512,512,512,512,512,512,512,512,512,},{512,512,512,512,512,2,512,512,512,512,512,2,2,2,512,512,512,512,512,},{512,512,512,512,512,2,512,512,512,512,512,512,512,2,512,512,512,512,512,},{512,512,512,512,512,2,512,512,512,512,512,512,512,2,512,512,512,512,512,},{0,512,512,512,512,2,2,2,2,2,2,2,2,2,512,512,512,512,},{0,0,512,512,512,512,512,512,512,512,512,512,512,512,512,512,512,},}
	--19 is width of img
	paintutils.drawImage(logo,(term.getSize()-19)/2,5)
	term.setBackgroundColor(colors.black)
 -- print()
 term.setCursorPos(1,15)
	cPrint("V"..strVer)
	if showLegal then
		cPrint"Game-Engine Copyright 2014 Jackson McNeill."
		cPrint"Distribute any version, but show & keep this"
		cPrint"license"
	end
end
cantCallDis(true)
if not devmode then
	sleep(2)
end
cWrite"LOADING..."
--default loading screen
function loadingScreen()
	cantCallDis()
	cPrint"LOADING..."
end
-------------------------
----[[Map functions]]----
-------------------------
--theoriginalbit's save thingy
--not mine
function log2(n)
	return math.floor(math.log(n) / math.log(2))
end

function packBoolean(nibble, bool)
	return bit.bor(bit.blshift(nibble, 1), bool and 1 or 0)
end

function unpackBoolean(byte, mask)
	return bit.band(byte, mask) == mask
end

function packByte(color, solid, cliff, water, battle)
	return bit.bor(bit.blshift(packBoolean(packBoolean(packBoolean(packBoolean(0, solid), cliff), water), battle), 4), log2(color))
end
function unpackByte( byte )
	return 2^bit.band(byte, 0xF), unpackBoolean(byte, 128), unpackBoolean(byte, 64), unpackBoolean(byte, 32), unpackBoolean(byte, 16)
end
--the rest is mine
function save(filename, map)
	--make file"
	if fs.exists(filename) then 
		fs.delete(filename)
	end
	fs.makeDir(filename)
	local stable={}
	local file = fs.open(filename.."/binary", "wb")
	local min =table.maxn(map)
	for q,w in pairs(map) do
		min = math.min(min,q)
		rest()
	end
	stable.starty = min
	local lasty = min
	local lastx =0 
	local minx
	for i,o in pairs(map) do
		for q,w in pairs(map[i]) do
			minx = math.min((minx or q-1),q)
			rest()
		end
		rest()
	end
	stable.startx = minx
	for i=min,table.maxn(map) do
		if map[i] then
			lastx = minx
			for p=1,(i-lasty) do --2 times
				file.write(240)
			end    
			lasty = i
			for o=minx,table.maxn(map[i]) do
				if map[i][o] then
					_,y = term.getCursorPos()--deb
					for p=1,(o-lastx)-1 do --1 times
						file.write(224)
					end
					lastx = o --5
					file.write(packByte(map[i][o].c,map[i][o].s,map[i][o].e,map[i][o].w,map[i][o].p))
					
				end
				rest()
			end
			rest()
		end
	end--[1]
	--# done w/ binary
	file.close()
	--write the table
	local i = fs.open(filename.."/table","w")
	i.write(textutils.serialize(stable))
	i.close()
end

function load(filename)
	traceEnter"load"
	if inputCheck({filename},{"string"},"load") then 
		traceExit"load"
		return 
	end
	--# the map
	local map = {}
	local i = fs.open(filename.."/table","r") --the serialized table contains information about the map other than pixels. It also contains events.
	local stable = i.readAll()
	i.close()
	if not stable then
		writeErrorToConsole"[load] Table part of save was not found!"
		traceExit"load" 
		return 
	end 
	stable = textutils.unserialize(stable)
	if not stable then 
		writeErrorToConsole"[load] Table part of save was not serialized properly!"
		traceExit"load"
		return 
	end 
	--# open the file in binary read mode
	local file = fs.open(filename.."/binary", "rb")
	if not file then 
		writeErrorToConsole"[load] Binary part of save was not found!"
		traceExit"load"
		return 
	end 
	local row, col = stable.starty,stable.startx+1
	--# read the file, 1 byte at a time
	local unpacked
	while true do
		local byte = file.read()
		if not byte then
			break
		end
		unpacked = {unpackByte(byte)}
		if unpacked[1] == 1 and unpacked[2] and unpacked[3] and unpacked[4] and unpacked[5] then--white, true on all, which is a newline thingy
			row = row+1
			col = stable.startx
		elseif unpacked[1] == 1 and unpacked[2] and unpacked[3] and unpacked[4] and not unpacked[5] then
			--col increase done for us
		else
			map[row] = map[row] or {}
			map[row][col] = {}

			--# unpack the byte into the row/column
			map[row][col].c = unpacked[1]
			map[row][col].s = unpacked[2]
			map[row][col].e = unpacked[3]
			map[row][col].w = unpacked[4]
			map[row][col].p = unpacked[5]
		end
		--col increasement
		col=col+1
		rest()
	end
	--# return the map and close the file, file.close returns nil, so you wont get a value from this
	traceExit"load"
	return map, file.close()
end
function loadMap(map,scrollx,scrolly,bg,tc,text)
	traceEnter"loadMap"
	if inputCheck({map,scrollx,scrolly,bg,tc,text},{"string","number","number", "number", "number", "string"},"loadMap") then
		traceExit"loadMap"
		return false 
	end
	--load the map
	map = load(map)
	if not map then 
		writeErrorToConsole"[loadMap] Map didn't load"
		traceExit"loadMap"
		return false 
	end
	local normTerm = term.current()
	map = printMap(map,scrollx,scrolly,bg,tc,text,normTerm)
	map.location = map
	traceExit"loadMap"
	return map

end







function loadMapOld(name, scrollx, scrolly,bg,tc,text)
	traceEnter"loadMapOld"
	local normTerm = term.current()
	if inputCheck({name,scrollx,scrolly,bg,tc,text},{"string","number","number", "number", "number", "string"},"loadMapOld") then
		traceExit"loadMapOld"
		return false 
	end
	text = string.sub(text,1,1)
	--ensure it is just 1 char
	--load a map and drop the char in an x and y pos.
	--get the map first
	if not fs.exists(name) then
		writeErrorToConsole"[FATAL?] loadMapOld - Specified file does not exist!"
		traceExit"loadMapOld"
		--return false 
	end
	local f=fs.open(name,"r")
	if f then
		local map=f.readAll()
		f.close()
		currentMap=textutils.unserialize(map)
	else
		map = name
	end
	traceExit"loadMapOld"
	name = printMap(currentMap,scrollx, scrolly,bg,tc,text,normTerm)
	name.location = name
	return name 
end
function printMap(currentMap, scrollx, scrolly,bg,tc,text,normTerm)
	traceEnter"printMap"
	--we've gotten the map part done, now we must draw it on a buffer
	local buffer=redirect.createRedirectBuffer(400,400)
	term.redirect(buffer)

	--set bg color
	term.setBackgroundColor(bg)
	term.setTextColor(tc)
	local termX,termY=term.getSize()
	for i=1,termY do
		for k = 1,termX do
			write(text)
		end
		print()
	end
	--print the map, code shamelessly ripped from my level editor
	for y,x in pairs(currentMap) do--for how many Y coords there are
		for c,v in pairs(currentMap[y]) do
			if type(currentMap[y][c]["c"])=="number" then
				paintutils.drawPixel(c+scrollx,y+scrolly,currentMap[y][c]["c"])
				if currentMap[y][c]["w"] == true then
					term.setCursorPos(c+scrollx,y+scrolly)
					term.setTextColor(colors.cyan)
					write"~"
				elseif currentMap[y][c]["e"]==true then
					term.setCursorPos(c+scrollx,y+scrolly)
					term.setTextColor(colors.black)
					write"_"
				elseif currentMap[y][c]["b"]==true then--grass or cave
					term.setCursorPos(c+scrollx,y+scrolly)
					if currentMap[y][c]["c"] == colors.lime then
						term.setTextColor(colors.green)
						write"^"
					elseif currentMap[y][c]["c"]==colors.green then
						term.setTextColor(colors.lime)
						write"^"
					else
						term.setTextColor(colors.black)
						write","
					end
				elseif currentMap[y][c]["v"] then
					term.setCursorPos(c+scrollx,y+scrolly)
					term.setTextColor(colors.black)
					write">"
				elseif currentMap[y][c]["event"] then--not in level editor
					--handle events
					--construct the arg handling
					currentMap[y][c]["event"]="local args = {...} local self = args[1]\n"..currentMap[y][c]["event"]
					--get an env for it
					local env = setmetatable({}, {__index=_G}) 
					local evtfnct = loadstring(currentMap[y][c]["event"])
					setfenv(evtfnct,env)
					local ok,err = pcall(evtfnct,currentMap[y][c])
					if not ok and err then
						writeErrorToConsole("[PrintMap @ X: "..c..", Y: "..y.."] "..tostring(err))
					end
				end
			end
		end
		rest()
	end
	term.redirect(normTerm)
	--now let's put the offset values into the map
	currentMap["offsetx"] =scrollx
	currentMap["offsety"] =scrolly
	--include the map in the buffer
	currentMap.render = buffer
	currentMap.handleMapEvents = intHandleMapEvents
	traceExit"printMap"
	return currentMap
end
--not done yet, uncomment when working on
--[[local function intHandleMapEvents(map,events,player)
	traceEnter"map:handleMapEvents"
	if inputCheck({map,events,player},{"table","table","table"},"map:handleMapEvents") then 
		traceExit"map:handleMapEvents"
		return false 
	end 
	if events[1]=="mouse_click" then 
		local actualx = events[3]+map.offsetx
		if events[2]==1 then 
			if 
	if map[events]
]]
function collision(map,x,y,offsetx,offsety,noneIsCollision,ifNothing)
	traceEnter"collision"
 -- writeToConsole("x:"..x.." y: "..y)-----------------------------------------------
	if x==1 or y==1 then
		writeToConsole"Collision - Due to engine limitations(*cough* redirect API *cough*), you cannot render the map at less than y 1 x 1."
		traceExit"collision"
		return true
	end
	--noclipped?
	if noclip then
		traceExit"collision"
		return false
	end
	--minus x and y by offset

	x=x-map["offsetx"]-1
	y=y-map["offsety"]-1
	----------writeToConsole("2x:"..x.." y: "..y)-------------------------------------------------------
	if type(map)=="table" and type(x)=="number" and type(y)=="number" then else
		writeErrorToConsole("collision - Expected table number number, got "..type(map)..", "..type(x)..", "..type(y))
	end
	if type(offsetx)=="number" then
		x=x+offsetx
	end
	if type(offsety)=="number" then
		y=y+offsety
	end
	if not map[y] then
		traceExit"collision"
		return noneIsCollision
	end
	if not map[y][x] then
		traceExit"collision"
		return noneIsCollision
	end
	if map[y][x]["s"] then
		traceExit"collision"
		return true  --true/false
	else
		if ifNothing and not map[y][x] then
			traceExit"collision"
			return true  
		end
		traceExit"collision"
		return false   
	end
	traceExit"collision"
end
---------------------------
-----[[Player System]]-----
---------------------------
function addPlayer(baseColor,textColor,text,drawx,drawy,map,noneIsCollision)
	traceEnter"addPlayer"
	inputCheck({baseColor,textColor,text,drawx,drawy,map},{"number","number","string","number","number","table"},"addPlayer")
	local playerTable = {}
	playerTable["baseColor"]=baseColor
	playerTable["textColor"] = textColor
	playerTable["text"]=text
	playerTable["x"] =1
	playerTable["y"] =1
	playerTable["drawx"]=drawx
	playerTable["drawy"]=drawy
	playerTable["map"] = map
	playerTable["noneIsCollision"] = noneIsCollision
	
	--functions
	function playerTable.setPos(self,x,y)
		traceEnter"playerTable:setPos"
		if inputCheck({self,x,y},{"table",{"number","nil"},{"number","nil"}}) then
			return false
		end
		self.x=x or self.x
		self.y = y or self.y
		traceExit"playerTable:setPos"
	end
	function playerTable.moveUp(self) 
		traceEnter"playerTable:moveUp"
		if collision(self.map,self.x,self.y-1,self.drawx,self.drawy,self.noneIsCollision) then else
			self:setPos(nil,self.y-1)--yes this looks backwards, welcome to my shotty cordinate system
		end
		--this is why I'm making these functions
		traceExit"playerTable:moveUp"
	end
	function playerTable.moveDown(self) 
		traceEnter"playerTable:moveDown"
		if collision(self.map,self.x,self.y+1,self.drawx,self.drawy,self.noneIsCollision) then else
			self:setPos(nil,self.y+1)
		end
		traceExit"playerTable:moveDown"
	end
	function playerTable.moveLeft(self) 
		traceEnter"playerTable:moveLeft"
		if collision(self.map,self.x-1,self.y,self.drawx,self.drawy,self.noneIsCollision) then else
			self:setPos(self.x-1,nil)--left and right isn't messed up at least!
		end
		traceExit"playerTable:moveLeft"
	end
	function playerTable.moveRight(self) 
		traceEnter"playerTable:moveRight"
		if collision(self.map,self.x+1,self.y,self.drawx,self.drawy,self.noneIsCollision) then else
			self:setPos(self.x+1,nil)
		end
		traceExit"playerTable:moveRight"
	end
	function playerTable.kill(self)
		traceEnter"playerTable:kill"
		self=nil--oooohh NOOOOOOOOO!!!(in heavy voice)
		traceExit"playerTable:kill"
	end
	function playerTable.restyle(self,baseColor,textColor,text,drawx,drawy,map,noneIsCollision)
		traceEnter"playerTable:restyle"
		self["baseColor"]=baseColor or self.baseColor
		self["textColor"]=textColor or self.textColor
		self["text"]=text or self.text
		self["drawx"] =drawx or self.drawx
		self["drawy"]=drawy or self.drawy
		self["map"] = map or self.map
		self["noneIsCollision"] = noneIsCollision or self.noneIsCollision
		traceExit"playerTable:restyle"
	end
	function playerTable.draw(self)
		traceEnter"playerTable:draw"
		term.setCursorPos(self.drawx,self.drawy)
		term.setBackgroundColor(self.baseColor)
		term.setTextColor(self.textColor)
		write(self.text)
		traceExit"playerTable:draw"
	end
	traceExit"addPlayer"
	return playerTable
end




--------------------------
----[[Windows System]]----
--------------------------
function addButton(text,x,y,bgcolor,txtcolor,table)
	traceEnter"addButton"
	--create a Button
	--check if its syntax is okay
	if inputCheck({text,x,y,bgcolor,txtcolor,table},{"string","number","number","number","number",{"table","nil"}},"addButton(button syntax)") then
		traceExit"addButton"
		return false 
	end
	--table var optional, if included will add it to the table and return it
	table=table or {}
	table[#table+1]={text,x,y,bgcolor,txtcolor}
	traceExit"addButton"
	return table 
end

function checkButtons(buttonsTable, eventsTable)
	traceEnter"checkButtons"
	if inputCheck({buttonsTable,eventsTable},{"table","table"},"checkButtons") then
		traceExit"checkButtons"
	end
	if not eventsTable[1]=="mouse_click"then
		return false
	end
	--check buttons given a table of buttons and a table of events
	local i
	for i=1,#buttonsTable do
		--check button syntax while we're at it
		if inputCheck({buttonsTable[i][1],buttonsTable[i][2],buttonsTable[i][3],buttonsTable[i][4],buttonsTable[i][5]},{"string","number","number","number","number"},"checkButtons(button syntax)") then
			traceExit"checkButtons"
			return false
		end
		if buttonsTable[i][3]==eventsTable[4]then--if on right y
		 if eventsTable[3]>=buttonsTable[i][2] then--if enough x
				if eventsTable[3]<=buttonsTable[i][2]+#buttonsTable[i][1] then --if not too much x
					traceExit"checkButtons"
					return buttonsTable[i][1], i --return buttons text and number
				end
			end
		end
	end
	traceExit"checkButtons"
end
function drawButtons(table)
	traceEnter"drawButtons"
	for i=1,#table do
		term.setCursorPos(table[i][2],table[i][3])
		term.setBackgroundColor(table[i][4])
		term.setTextColor(table[i][5])
		write(table[i][1])
	end
	traceExit"drawButtons"
end
function makeCheckbox(x,y,onbgcolor,ontxcolor,offbgcolor,offtxcolor,ontext,offtext,def,clickable,table)
	traceEnter"makeCheckbox"
	if inputCheck({x,y,onbgcolor,ontxcolor,offbgcolor,offtxcolor,ontext,offtext,def,clickable,table},{"number","number","number","number","number","number","string","string","boolean","boolean", {"table","nil"}},"makeCheckbox") then
		traceExit"makeCheckbox"
		return false
	end  
	table = table or {}
	--does a checkbox at this pos exist?
	for i=1,#table do
		if table[i].x ==x or table[i].y == y then
			writeErrorToConsole("[makeCheckbox] - Checkbox in that coordinate already exist. X: "..x.."; Y: "..y)
			traceExit"makeCheckbox"
			return false
		end
	end
	table[#table+1]={}
	table[#table]["x"]=x 
	table[#table]["y"]=y
	table[#table]["onbgcolor"]=onbgcolor
	table[#table]["ontxcolor"]=ontxcolor
	table[#table]["offbgcolor"]=offbgcolor
	table[#table]["offtxcolor"] =offtxcolor
	table[#table]["ontext"]=ontext
	table[#table]["offtext"] =offtext
	table[#table]["on"]=def
	table[#table]["clickable"]=clickable
	--functions
	table[#table].adjust = function(self,x,y,onbgcolor,ontxcolor,offbgcolor,offtxcolor,ontext,offtext,clickable)
		traceEnter"checkbox:adjust"
		self={}
		table[#table]["x"]=x or self.x
		table[#table]["y"]=y or self.y
		table[#table]["onbgcolor"]=onbgcolor or self.onbgcolor
		table[#table]["ontxcolor"]=ontxcolor or self.ontxcolor
		table[#table]["offbgcolor"]=offbgcolor or self.offbgcolor
		table[#table]["offtxcolor"] =offtxcolor or self.offtxcolor
		table[#table]["ontext"]=ontext or self.ontext
		table[#table]["offtext"] =offtext or self.offtext
		table[#table]["clickable"] = clickable or self.clickable
		traceExit"checkbox:adjust"
	end
	table[#table].setToggled = function(self,toggled)
		traceEnter"checkbox:setToggled"
		if inputCheck({self,toggled},{"table","boolean"},"Checkbox:setToggled") then
			traceExit"Checkbox:setToggled"
			return false
		end
		self.on = toggled
		traceExit"checkbox:setToggled"
	end
	--the rest handled by a mass button handler, which is much easier to call
	traceExit"makeCheckbox"
	return table[#table]
end
function handleCheckboxes(checkTable,events)
	traceEnter"handleCheckboxes"
	if inputCheck({checkTable,events},{"table","table"},"handleCheckboxes") then
		traceExit"handleCheckboxes"
		return false
	end
	if not events[1]=="mouse_click" then
		traceExit"handleCheckboxes"
		return false
	end
	for i=1,#checkTable do
		if events[3]==checkTable[i]["x"] and events[4]==checkTable[i]["x"] then
			writeToConsole(tostring(not checkTable[i]["on"]))
			checkTable[i]:setToggled(not checkTable[i]["on"])
			--they can't click 2 checkboxes at once... hopefully...
			traceExit"handleCheckboxes"
			return
		end
	end
	traceExit"handleCheckboxes"
end
function drawCheckbox(checktable)
	traceEnter"drawCheckbox"
	if inputCheck({checktable},{"table"},"drawCheckbox") then
		traceExit'drawCheckbox'
		return false
	end
	--[[for i,o in pairs(checktable[1]) do
		writeToConsole(i)
		writeToConsole(checktable[1][i])
	end]]
	for i=1,#checktable do      
		term.setCursorPos(checktable[i].x,checktable[i].y)
		if checktable[i]["on"] then
			term.setBackgroundColor(checktable[i].onbgcolor or colors.white)
			term.setTextColor(checktable[i].ontxcolor or colors.black)
			term.write(checktable[i]["ontext"] or "?")
		else
			term.setBackgroundColor(checktable[i].offbgcolor or colors.white)
			term.setTextColor(checktable[i].offtxcolor or colors.black)
			term.write(checktable[i]["offtext"] or "?")
		end
	end
	traceExit"drawCheckbox"
end
function makeConfigBox(contents,x,y,lx,ly,bgcolor,txcolor)
	traceEnter"makeConfigBox"
	if inputCheck({contents,x,y,lx,ly,bgcolor,txcolor},{"table","number","number","number","number","number","number"},"makeConfigBox") then
		traceExit"makeConfigBox"
		return false
	end
	term.setCursorPos(1,y)
	local configBox = {}
	configBox["contents"] = contents
	configBox["x"] = x
	configBox["y"] = y
	configBox["lx"] = lx
	configBox["ly"] = ly   
	configBox["bgcolor"] = bgcolor
	configBox["txcolor"] =  txcolor
	configBox["scrollx"] = 0
	configBox["scrolly"] = 0    
	function configBox.draw(self)
		traceEnter"configBox:draw"
		if inputCheck({self.contents,self.x,self.y,self.lx,self.ly,self.bgcolor,self.txcolor},{"table","number","number","number","number","number","number"},"configBox:draw") then
			traceExit"configBox:draw"
			return false
		end
		term.setBackgroundColor(self.bgcolor)
		term.setTextColor(self.txcolor)
		term.setCursorPos(1,self.y)
		local spacing = ""
		for i=1,self.lx do
			spacing=spacing.." "
		end
		local pvar
		for i=1+self.scrolly,self.ly+self.scrolly do
			setX(self.x)
			pvar = self.contents[i] or spacing
			print(string.sub(pvar..string.sub(spacing,1,lx-#pvar),1+self.scrollx,self.lx+self.scrollx) or spacing)
		end
		traceExit"configBox:draw"
	end
	function configBox.setScroll(self,x,y)
		traceEnter"configBox:setScroll"
		if inputCheck({self.contents,self.x,self.y,self.lx,self.ly,self.bgcolor,self.txcolor},{"table","number","number","number","number","number","number"},"configBox:setScroll") then
			traceExit"configBox:setScroll"
			return false
		end
		if (y+self.ly) <= #self.contents and y >= 0 then
			self.scrolly = y or self.scrolly
		end
		local longestEntry = 1
		for i=1+self.scrolly,self.ly+self.scrolly do
			if #self.contents[i]> longestEntry then
				longestEntry=#self.contents[i]
			end
		end

		writeToConsole(longestEntry)
		if x <= longestEntry-self.lx and x>=0 then
			self.scrollx=x or self.scrollx
		end   
		--has it now become greater than the norm for that y, if we moved it?
		if self.scrollx > longestEntry then
			writeToConsole"yus"
			self.scrollx=0
		end   
		traceExit"configBox:setScroll"
	end
	function configBox.addScroll(self,x,y)
		x=x or 0
		y=y or 0
		return configBox:setScroll(x+self.scrollx,y+self.scrolly)
	end
	traceExit"makeConfigBox"
	return configBox
end


function makeGui(yoloSwagEasterEgg)
	




end

function defaultMainMenu()


end

--NOT FUNCTIONAL RIGHT NOW. PLEASE DO NOT USE.
-------------------------------
------[[Compiler System]]------
-------------------------------
function findEndOfCommand(str,start,enders)
	traceEnter"findEndOfCommand"
	enders = enders or {" ","\n",")"}
	local finds = {}
	local strShort = string.sub(str,start,#str)
	for i=1,#enders do 
		finds[i]=string.find(strShort,enders[i],1,false)
	end 
	for i=1,table.maxn(finds) do
		if finds[i] then 
			min=math.min(min or finds[i]-1,finds[i])
		end 
	end 
	if min then 
		min = min+#string.sub(str,1,start)
	else 
		min = #str
		l"[findEndOfCommand] Couldn't find an ender! Setting to last part of string..."
	end
	traceExit"findEndOfCommand"
	return min,string.sub(str,min,min)--location and what it was
end
function replace(str,start,enda,what)
	traceEnter"replace"
	local firstHalf = string.sub(str,1,start)
	local secondHalf = string.sub(str,enda,#str)
	traceExit"replace"
	return firstHalf..what..secondHalf
end
function removeCrap(strNoCrap,crap,endingThingy,fourthA)
	endingThingy = endingThingy or crap
	local start 
	local enda
	while true do 
		start = string.find(strNoCrap,crap,1,not fourthA)
		if not start then 
			break 
		end
		--find end
		enda = findEndOfCommand(strNoCrap,start+#crap,{endingThingy})
		if not enda then 
			break 
		end
		local whitespace = ""
		for i=start,enda do 
			whitespace=whitespace.." "
		end 
		strNoCrap=replace(strNoCrap,start-1,enda+1,whitespace)
		l("s:"..strNoCrap.." sta: "..tostring(start).." end: "..tostring(enda))
	end
	return strNoCrap
end
function findFunction(strNoCrap,str,start)
	--find the next spot where they say "function"
	local spot= string.find(strNoCrap,"function",start)
	--are they declaring this like: function x() or x=function()
	local par = string.find(strNoCrap,"(",spot+8)



end

function compileString(str,debugTable)
	traceEnter"compileString"
	--we want to add an extra new line at the end, just to be save
	str=str.."\n"
	--sub out all comments and strings in a seperate variable 
	local strNoCrap = str 
	--sub out \" and \' because they'd get in the way
	strNoCrap=string.gsub(strNoCrap,'\\"',"  ")
	strNoCrap=string.gsub(strNoCrap,"\\'","  ")
	strNoCrap =removeCrap(strNoCrap,'"')
	strNoCrap = removeCrap(strNoCrap,"'")	
	--note the order we do this in. we don't want extra --'s floating arround.
	strNoCrap = removeCrap(strNoCrap,"--[[","]]")
	strNoCrap = removeCrap(strNoCrap,"[[","]]")
	strNoCrap = removeCrap(strNoCrap,"--","\n")

	if #strNoCrap ~= #str then 
		e("Warning - String & commentless version of program is not the same size as the program itself! "..#strNoCrap.." vs. "..#str..". The compilation is EXTEMELY likely to fail.")
	end
	--temp
	traceExit"compileString"
	return strNoCrap
end
